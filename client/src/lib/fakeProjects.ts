/**
 * Fake project generator for demo/ambient visualization
 *
 * When there are â‰¤3 real projects, we generate fake projects with
 * agents doing "Very Important Things" to fill the dashboard.
 * Can optionally use real git commits for more realistic activities.
 */

import type { Project, Agent, AgentStatus } from '../../../shared/types';

// Git activity type from server
export interface GitActivity {
  activity: string;
  suggestedRole: string;
}

// Store for git-based activities (populated from server)
let gitActivities: GitActivity[] = [];

/**
 * Fetch git activities from server
 */
export async function fetchGitActivities(): Promise<void> {
  try {
    const response = await fetch('/git-activities');
    if (response.ok) {
      const data = await response.json();
      gitActivities = data.activities || [];
    }
  } catch (e) {
    // Failed to fetch, will use built-in activities
    gitActivities = [];
  }
}

// Fake project names (tech/dev themed)
const FAKE_PROJECT_NAMES = [
  'quantum-flux-capacitor',
  'neural-pancake-stack',
  'distributed-coffee-maker',
  'async-sandwich-builder',
  'parallel-nap-scheduler',
  'recursive-snack-finder',
  'microservice-pet-feeder',
  'blockchain-weather-guesser',
];

// Try to load extended activities from JSON (generated by scripts/generate-phrases.py)
// Falls back to built-in activities if JSON not available
let extendedActivities: Record<string, string[]> | null = null;

// Async load extended activities (non-blocking)
async function loadExtendedActivities() {
  try {
    const response = await fetch('/fakeActivities.json');
    if (response.ok) {
      extendedActivities = await response.json();
      console.log('[FakeProjects] Loaded extended activities:',
        Object.entries(extendedActivities || {}).map(([k, v]) => `${k}: ${v.length}`).join(', '));
    }
  } catch (e) {
    // Extended activities not available, will use built-in
  }
}

// Start loading immediately
loadExtendedActivities();

// Fake agent roles and their "Very Important" activities (built-in fallback)
const BUILTIN_ACTIVITIES: Record<string, string[]> = {
  architect: [
    'Contemplating the architecture of architectures',
    'Drawing boxes inside boxes inside boxes',
    'Debating microservices vs monolith (again)',
    'Optimizing the optimization optimizer',
    'Sketching diagrams that require 4 monitors',
    'Whiteboarding a solution that requires 6 databases',
    'Designing an event-driven system for a TODO app',
    'Wondering if this needs more abstraction layers',
    'Creating a design doc for the design doc process',
    'Calculating the theoretical maximum throughput of naps',
  ],
  executor: [
    'Implementing a feature that was specced 5 minutes ago',
    'Refactoring the refactored refactor',
    'Adding TODO comments for future TODOs',
    'Writing code that writes code',
    'Fixing the bug that fixes the other bug',
    'Deploying to production on a Friday (sorry)',
    'Turning coffee into questionable pull requests',
    'Achieving a new personal record in console.log statements',
    'Renaming variables to make them more variable-y',
    'Implementing dark mode for the third time this sprint',
  ],
  explorer: [
    'Searching for the missing semicolon',
    'Exploring the depths of node_modules',
    'Mapping the uncharted regions of legacy code',
    'Following the call stack into the void',
    'Discovering ancient code from 2019',
    'Spelunking through a 5000-line function',
    'Searching for who wrote this and why',
    'Tracing the origin of this mysterious any type',
    'Finding the config file that nobody documented',
    'Investigating why there are two src folders',
  ],
  designer: [
    'Adjusting padding by 1 pixel',
    'Debating 47 shades of blue',
    'Making the button more buttony',
    'Centering the div (attempt #47)',
    'Adding subtle drop shadows to everything',
    'Tweaking border-radius for emotional impact',
    'Applying gradient therapy to stressed components',
    'Perfecting the hover state of existence',
    'Making the loading spinner more hypnotic',
    'Considering whether Comic Sans was really that bad',
  ],
  researcher: [
    'Reading documentation that may or may not exist',
    'Googling the error message (professionally)',
    'Comparing 12 npm packages that do the same thing',
    'Investigating why it works on their machine',
    'Researching best practices from 2015',
    'Reading the source code because the docs lied',
    'Discovering the library was deprecated yesterday',
    'Finding a Stack Overflow answer from 2011 that still works',
    'Learning that the "easy" solution requires 47 dependencies',
    'Studying why the tests pass locally but not in CI',
  ],
  writer: [
    'Writing docs that nobody will read',
    'Crafting the perfect README intro',
    'Explaining why the code is self-documenting',
    'Adding JSDoc to a function called "doThing"',
    'Writing a comment longer than the code',
    'Documenting the undocumentable',
    'Creating a changelog entry for changing a changelog',
    'Writing "See above" in three different sections',
    'Explaining what the code does, not why it exists',
    'Adding emoji to make docs feel more welcoming ðŸŽ‰',
  ],
  tester: [
    'Testing if tests are testing the right tests',
    'Writing edge cases for edge cases',
    'Achieving 100% coverage of trivial getters',
    'Mocking the mocks that mock other mocks',
    'Finding the one bug that passed all tests',
    'Discovering the feature works by accident',
    'Testing what happens when everything goes wrong at once',
    'Verifying that null is indeed null',
    'Creating a test named "it should work" and hoping for the best',
    'Running the same test 3 times to confirm it is flaky',
  ],
  planner: [
    'Planning the plan for planning',
    'Creating tickets about creating tickets',
    'Estimating that estimates are always wrong',
    'Scheduling meetings about the meeting schedule',
    'Prioritizing the priority prioritization',
    'Moving cards from "To Do" to "Doing" dramatically',
    'Calculating velocity using advanced horoscope methods',
    'Defining "done" for the definition of done',
    'Creating a roadmap to the roadmap',
    'Assigning story points based on vibes',
  ],
};

// Get activities for a role (prefers extended, falls back to built-in)
function getActivitiesForRole(role: string): string[] {
  if (extendedActivities && extendedActivities[role]?.length > 0) {
    return extendedActivities[role];
  }
  return BUILTIN_ACTIVITIES[role] || BUILTIN_ACTIVITIES.executor;
}

const ROLES = Object.keys(BUILTIN_ACTIVITIES);

// Get an activity for an agent (prefers extended > git > built-in)
function getActivity(role: string): string {
  // First try: extended activities from JSON (if loaded)
  const extended = getActivitiesForRole(role);
  if (extended !== BUILTIN_ACTIVITIES[role]) {
    return extended[Math.floor(Math.random() * extended.length)];
  }

  // Second try: git activities (they have suggested roles)
  if (gitActivities.length > 0) {
    // Find activities that match this role
    const matchingActivities = gitActivities.filter(
      a => a.suggestedRole === role
    );

    if (matchingActivities.length > 0) {
      return matchingActivities[Math.floor(Math.random() * matchingActivities.length)].activity;
    }

    // No matching role, use any git activity
    const randomGit = gitActivities[Math.floor(Math.random() * gitActivities.length)];
    return randomGit.activity;
  }

  // Fall back to built-in funny activities
  const activities = BUILTIN_ACTIVITIES[role] || BUILTIN_ACTIVITIES.executor;
  return activities[Math.floor(Math.random() * activities.length)];
}

// Generate a random fake agent
function generateFakeAgent(
  projectId: string,
  index: number,
  now: number
): Agent {
  const role = ROLES[index % ROLES.length];
  const activity = getActivity(role);

  // Random status weighted towards working (NEVER blocked - fake projects shouldn't distract)
  const statusRoll = Math.random();
  let status: AgentStatus;
  if (statusRoll < 0.75) {
    status = 'working';
  } else {
    status = 'complete';
  }

  // Stagger spawn times for visual variety
  const spawnedAt = now - Math.floor(Math.random() * 300000); // 0-5 min ago
  const lastActivityAt = now - Math.floor(Math.random() * 30000); // 0-30s ago

  return {
    id: `${projectId}-fake-agent-${index}`,
    name: role,
    type: index === 0 ? 'main' : 'subagent',
    parentId: index === 0 ? undefined : `${projectId}-fake-agent-0`,
    status,
    task: activity,
    currentActivity: activity,
    // No question field - fake projects should never be blocked
    spawnedAt,
    lastActivityAt,
    workingTime: now - spawnedAt,
  };
}

// Generate a fake project
function generateFakeProject(index: number, now: number): Project {
  const name = FAKE_PROJECT_NAMES[index % FAKE_PROJECT_NAMES.length];
  const id = `fake-${name}-${index}`;

  // Generate 2-4 agents per project
  const agentCount = 2 + Math.floor(Math.random() * 3);
  const agents: Record<string, Agent> = {};

  for (let i = 0; i < agentCount; i++) {
    const agent = generateFakeAgent(id, i, now);
    agents[agent.id] = agent;
  }

  // Determine project status from agents
  const agentList = Object.values(agents);
  const hasBlocked = agentList.some(a => a.status === 'blocked');
  const hasWorking = agentList.some(a => a.status === 'working');

  return {
    id,
    path: `/fake/${name}`,
    name: `Fake: ${name}`,
    status: hasBlocked ? 'blocked' : hasWorking ? 'working' : 'idle',
    lastActivityAt: now - Math.floor(Math.random() * 60000),
    blockedSince: hasBlocked ? now - Math.floor(Math.random() * 120000) : undefined,
    agents,
    blockedAgentCount: agentList.filter(a => a.status === 'blocked').length,
    workingAgentCount: agentList.filter(a => a.status === 'working').length,
  };
}

/**
 * Generate fake projects to fill dashboard up to 3 total projects
 * @param realProjectCount Number of actual projects
 * @returns Array of fake projects (fills up to 3 total)
 */
export function generateFakeProjects(realProjectCount: number): Project[] {
  // Only generate fake projects if <3 real ones (fill to 3 total)
  if (realProjectCount >= 3) {
    return [];
  }

  const now = Date.now();
  const fakeCount = 3 - realProjectCount; // Fill up to exactly 3 total
  const fakeProjects: Project[] = [];

  for (let i = 0; i < fakeCount; i++) {
    fakeProjects.push(generateFakeProject(i, now));
  }

  return fakeProjects;
}

/**
 * Periodically update fake project activities for animation
 * Call this every few seconds to make fake agents look alive
 */
export function refreshFakeActivities(projects: Project[]): Project[] {
  const now = Date.now();

  return projects.map(project => {
    if (!project.id.startsWith('fake-')) {
      return project;
    }

    // Update agent activities randomly
    const updatedAgents: Record<string, Agent> = {};

    for (const [id, agent] of Object.entries(project.agents)) {
      const role = agent.name || 'executor';

      // 20% chance to change activity (uses git activities if available)
      const newActivity = Math.random() < 0.2
        ? getActivity(role)
        : agent.currentActivity;

      // Small chance to change status (NEVER blocked - fake projects shouldn't distract)
      let newStatus = agent.status;
      if (Math.random() < 0.05) {
        newStatus = Math.random() < 0.75 ? 'working' : 'complete';
      }

      updatedAgents[id] = {
        ...agent,
        currentActivity: newActivity,
        task: newActivity,
        status: newStatus,
        lastActivityAt: now,
        // No question field - fake projects should never be blocked
      };
    }

    // Recalculate project status
    const agentList = Object.values(updatedAgents);
    const hasBlocked = agentList.some(a => a.status === 'blocked');
    const hasWorking = agentList.some(a => a.status === 'working');

    return {
      ...project,
      agents: updatedAgents,
      status: hasBlocked ? 'blocked' : hasWorking ? 'working' : 'idle',
      lastActivityAt: now,
      blockedSince: hasBlocked && !project.blockedSince ? now : project.blockedSince,
      blockedAgentCount: agentList.filter(a => a.status === 'blocked').length,
      workingAgentCount: agentList.filter(a => a.status === 'working').length,
    };
  });
}
